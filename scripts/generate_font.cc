/**
 * Generate the font used for DebugUI.
 * Copyright (C) 2024  dbstream
 */
#include <ft2build.h>
#include <freetype/freetype.h>
#include <stdint.h>
#include <assert.h>

#define STB_RECT_PACK_IMPLEMENTATION 1
#include "stb_rect_pack.h"

static FT_Library ft;
static FT_Face font;

// C++ basic charset without tabulation and newlines
static char charset[] =
" !\"#%&'()*+,-./0123456789:;<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_abcdefghijklmnopqrstuvwxyz{|}~$@`";

static constexpr int NUM_CHARS = sizeof (charset) - 1;
static_assert (NUM_CHARS == 95);

static stbrp_rect glyph_rects[NUM_CHARS];
static int num_glyph_rects = 0;

struct glyphdata {
	bool exists;
	int xoffset, yoffset;
	int advance;
	int width, height;
	int atlas_xoffset;
	int atlas_yoffset;
};

static glyphdata glyphs[256] {};

int
main (int argc, char **argv)
{
	if (argc != 3) {
		fprintf (stderr, "usage: ./generate_font /path/to/font.ttf LGE::Font::Namespace > font.cc\n");
		return 1;
	}

	FT_Error e = FT_Init_FreeType (&ft);
	if (e != FT_Err_Ok)
		return 1;

	e = FT_New_Face (ft, argv[1], 0, &font);
	if (e != FT_Err_Ok)
		return 1;

	e = FT_Set_Pixel_Sizes (font, 0, 12);
	if (e != FT_Err_Ok)
		return 1;

	for (char c : charset) {
		FT_UInt glyph_idx = FT_Get_Char_Index (font, c);
		if (!glyph_idx)
			continue;

		e = FT_Load_Glyph (font, glyph_idx, FT_LOAD_DEFAULT);
		if (e != FT_Err_Ok)
			return 1;

		FT_GlyphSlot slot = font->glyph;
		e = FT_Render_Glyph (slot, FT_RENDER_MODE_NORMAL);
		if (e != FT_Err_Ok)
			return 1;

		glyphs[c].exists = true;
		glyphs[c].xoffset = slot->bitmap_left;
		glyphs[c].yoffset = slot->bitmap_top;
		glyphs[c].advance = slot->advance.x / 64;
		glyphs[c].width = slot->metrics.width / 64;
		glyphs[c].height = slot->metrics.height / 64;
		glyphs[c].atlas_xoffset = 0;
		glyphs[c].atlas_yoffset = 0;

		if (glyphs[c].width && glyphs[c].height) {
			glyph_rects[num_glyph_rects++] = {
				.id = c,
				.w = glyphs[c].width,
				.h = glyphs[c].height,
				.x = 0,
				.y = 0,
				.was_packed = 0
			};
		}
	}

	int atlas_size = 32;

	for (;;) {
		stbrp_node *nodes = new stbrp_node[atlas_size];

		stbrp_context ctx = {};
		stbrp_init_target (&ctx, atlas_size, atlas_size, nodes, atlas_size);

		int result = stbrp_pack_rects (&ctx, glyph_rects, num_glyph_rects);
		delete[] nodes;

		if (result)
			break;

		atlas_size *= 2;
	}

	printf (R"code(/**
 * Font data for %s, generated by scripts/generate_font.
 * Copyright (C) 2024  dbstream
 *
 * %s is Copyright (C) its authors
 */
#include <stdint.h>
#include <stddef.h>

namespace %s {

static constexpr size_t font_bitmap_size = %d;
static const uint8_t font_bitmap[font_bitmap_size * font_bitmap_size] = {
)code", argv[1], argv[1], argv[2], atlas_size);

	for (int i = 0; i < num_glyph_rects; i++) {
		char c = glyph_rects[i].id;
		glyphs[c].atlas_xoffset = glyph_rects[i].x;
		glyphs[c].atlas_yoffset = glyph_rects[i].y;
	}

	uint8_t *buffer = new uint8_t[atlas_size * atlas_size];
	for (size_t i = 0; i < atlas_size * atlas_size; i++)
		buffer[i] = 0;

	for (char c : charset) {
		FT_UInt glyph_idx = FT_Get_Char_Index (font, c);
		if (!glyph_idx)
			continue;

		e = FT_Load_Glyph (font, glyph_idx, FT_LOAD_DEFAULT);
		if (e != FT_Err_Ok)
			return 1;

		FT_GlyphSlot slot = font->glyph;
		e = FT_Render_Glyph (slot, FT_RENDER_MODE_NORMAL);
		if (e != FT_Err_Ok)
			return 1;

		assert (slot->metrics.width / 64 == glyphs[c].width);
		assert (slot->metrics.height / 64 == glyphs[c].height);

		for (int y = 0; y < glyphs[c].height; y++) {
			uint8_t *src = &slot->bitmap.buffer[y * slot->bitmap.pitch];
			uint8_t *dst = &buffer[(y + glyphs[c].atlas_yoffset) * atlas_size + glyphs[c].atlas_xoffset];
			for (int x = 0; x < glyphs[c].width; x++)
				dst[x] = src[x];
		}
	}

	for (int y = 0; y < atlas_size; y++) {
		uint8_t *src = &buffer[y * atlas_size];
		for (int x = 0; x < atlas_size; x++)
			printf ("%3d,", (int) src[x]);
		printf("\n");
	}

	printf (R"code(};

struct glyph {
	bool exists;
	int advance;
	int width, height;
	int xoffset, yoffset;
	int atlas_xoffset, atlas_yoffset;
};

static constexpr int MAX_CHARSET = 256;

static const glyph glyphs[MAX_CHARSET] = {
)code");

	for (int i = 0; i < 256; i++) {
		if (!glyphs[i].exists) {
			printf ("\t{ 0 },\n");
			continue;
		}

		printf (R"code(	{
		true,
		%d,
		%d, %d,
		%d, %d,
		%d, %d
	},
)code", glyphs[i].advance, glyphs[i].width, glyphs[i].height,
			glyphs[i].xoffset, glyphs[i].yoffset,
			glyphs[i].atlas_xoffset, glyphs[i].atlas_yoffset);
	}

	printf (R"code(};

}

)code");

	return 0;
}
